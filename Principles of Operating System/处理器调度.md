## CPU调度

CPU是按照一定的调度算法从就绪队列中选择一个进程，然后把CPU的使用权交给被选中的进程，如果没有就绪进程，系统就会安排一个系统空闲进程或者idle进程。

### CPU调度需要解决的三个问题

+ 按什么原则选择下一个要执行的进程？-> 调度算法
+ 什么时候进行选择？-> 调度时机
+ 如何让被选中的进程上CPU运行？-> 进程的上下文切换

### CPU调度的时机

当事件发生，当前运行的进程就会暂停运行，硬件机制响应这个事件，进入操作系统，处理响应时间，结束处理后：某些进程的状态会发生改变，也有可能又会创建一些新的进程，**当就绪队列改变的时候，就需要进程调度根据调度算法从就绪队列中选择一个进程。**

当发生以下情况的时候，就会发生CPU调度：

+ 进程正常终止或者由于某种错误而终止。
+ 新进程创建或一个等待进程变成就绪。
+ 当一个进程从运行态进入阻塞态。
+ 当一个进程从运行态变为就绪态。

#### 典型的事件

+ 创建、唤醒、退出等进程控制操作
+ 进程等待IO，IO中断。
+ 时钟中断：比如时间片用完，计时器到时。
+ 进程执行过程中出现abort异常。

### 调度过程-进程切换

进程调度程序从就绪队列选择了要运行的进程，这个进程可以是刚刚被暂停的进程，也可以是一个新的进程，如果是新的进程，就会发生进程切换。

进程切换是指一个进程让出CPU，让新进程占用CPU的过程。

进程切换的两个部分工作：

+ 切换全局页目录可以加载一个新的地址空间。
+ 切换内核栈和硬件上下文，其中硬件上下文包括内核执行新进程想要的全部信息，比如CPU相关的寄存器。

切换进程包括对原来运行进程各种状态的保存和对新的进程各种状态的恢复。

### 上下文切换具体步骤

假设当前场景是：进程A下CPU，进程B上CPU。

+ 保存进程A的上下文环境(程序计数器，程序状态字，其他寄存器)
+ 用新状态和其他相关信息更新进程A的PCB。
+ 把进程A移到合适的队列(就绪，阻塞...)
+ 把进程B的状态设置为运行态
+ 从进程B的PCB中回复上下文

### 上下文切换开销

+ 直接开销：内核完成切换所用的CPU事件
  + 保存和恢复寄存器
  + 切换地址空间
+ 间接开销
  + 高速缓存(cache)，缓冲区缓存(Buffer Cache)和TLB失效

### CPU调度算法的设计

从不同的角度出发有不同的设计目标，从用户角度出发：

+ 周转时间
+ 响应时间
+ 最后期限

系统角度出发：

+ 吞吐量
+ CPU利用率
+ 公平性
+ 强制优先级
+ 平衡资源

### 调度算法衡量指标

+ 吞吐量(越大越好)：每单位时间内完成的进程数量。
+ 周转时间(越短越好)：每个进程从提出请求到运行完成的时间。
+ 响应时间(越短越好)：每个进程从提出请求到收到回应的时间。
+ CPU利用率(越忙越好)：CPU做的有效工作时间比例。
+ 等待时间(越短越好)：每个进程在就绪队列中等待的时间。

### 设计调度算法所需要考虑的问题

+ 进程控制块PCB中需要记录那些和CPU调度有关的信息。
+ 进程优先级就绪队列的组织。
+ 抢占式调度与非抢占式调度
+ IO密集型与CPU密集型进程
+ 时间片分配

### 进程优先级与优先数

#### 静态优先级

进程创建时指定，进程运行过程中不能在改变。

#### 动态优先级

进程创建时制定了一个优先级，运行过程中可以动态变化，比如等待较长的进程可以提升其优先级。

### 就绪队列组织

+ 按优先级排队
+ 

### 占用CPU的方式

+ 抢占式
+ 非抢占式

#### 可抢占式

当有比正在运行的进程优先级更高的进程进入就绪态的时候，**系统可以强行让正在运行的进程下CPU**，提供给具有更高优先级的进程使用。

#### 非抢占式

某一进程被调度运行之后，除非它自身原因不能运行，否则的话就会一直运行下去。

### IO密集型与CPU密集型进程

#### IO密集型进程

频繁的进程IO，通常会花更多时间等待IO操作的完成。

#### CPU密集型进程

需要大量的CPU时间进行计算。

从调度算法角度来看，调度算法更偏好于IO密集型进程，因为只用很短的时间占用CPU。

### 时间片

时间片是一个时间段，分配给调度上CPU的进程，设计一个时间片大小的时候需要考虑以下问题：

+ 进程切换的开销。
+ 对响应时间的要求。
+ 就绪进程的个数。
+ CPU的能力。
+ 进程的行为。

## 批处理系统中采用的调度算法

+ 先来先服务FCFS
+ 最短作业优先 SJF
+ 最短剩余时间优先
+ 最高相应比有限HRRN

批处理系统调度算法需要考虑以下问题：

+ 吞吐量
+ 周转时间
+ CPU利用率
+ 公平，平衡。

### 先来先服务

+ 先进先出
+ 按照进程就绪的先后顺序使用CPU
+ 非抢占式

它的优点是公平实现简单，但是缺点是长进程之后的短进程需要等待很长的时间，不利于用户体验。

调度算法的可以提高周转时间。

### 短作业优先算法

+ 最短完成时间的进程优先级最高。
+ 非抢占式
+ 最短剩余时间优先

除了非抢占式短作业有限算法，还有一种抢占式短作业优先算法，当一个新的进程进入就绪态之后，它的完成时间比当前时间还要短，系统就会抢占当前进程，选择新进程执行。

#### 短作业优先调度算法优点

在所有进程同时可运行时，采用SJF调度算法可以得到最短的平均周转时间。

#### 短作业优先调度算法缺点

它是不公平的，当越来越多的短进程进入到就绪队列中，那长进程就得不到运行，这样就会发生饥饿现象。

### 最高相应比优先

+ 是一个综合算法
+ 调度的时候，首先计算每个进程的相应比R，之后总是选择R最高的进程执行。

## 交互性系统中采用的调度算法

+ 轮转调度RR
+ 最高优先级调度HPF
+ 多级反馈队列
+ 最短进程优先

交互性系统追求的指标是：

+ 响应时间
+ 公平
+ 平衡

### 时间片轮转调度算法

为短任务改善平均响应时间，解决问题的思路如下：

+ 周期性切换
+ 每个进程分配一个时间片
+ 时钟中断-> 轮换

#### 如何选择一个合适的时间片？

+ 时间片太长，大于经典的交互时间
  + 会变成先来先服务去算法
  + 延长短进程的响应时间
+ 时间片太短，小于典型的交互时间
  + 会浪费CPU的时间，因为进程切换也需要时间。

#### 时间片轮转调度算法优点

+ 公平
+ 有利于交互式计算，响应时间快。

#### 时间片轮转调度算法缺点

+ 由于进程切换，时间片轮转算法要花费较高的开销。
+ RR对于不同大小的进程是有利的，但是对于相同大小的进程就不太友好。

### 虚拟轮换算法

### 最高优先级调度算法

总是选择优先级最高的进程投入运行，通常的优先级如下：

+ 系统进程优先级高于用户进程
+ 前台进程高于后台进程
+ 操作系统更偏好于IO型进程
+ 优先级可以是静态不变的，也可以是动态调整，优先数可以决定优先级。
+ 就绪队列可以按照优先级组织
+ 实现简单，但是不公平，会导致饥饿现象。