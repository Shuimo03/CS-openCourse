## 前置知识

### 一致性算法

一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现了故障(比如宕机)也能继续运行下去。

#### 可用性

+ 可读写
+ 可读
+ 不可用

### 一致性

+ 立即一致性
+ 最终一致性

而一致性算法就能够解决之前提到过的问题，**所以能够组织机器使其状态为最终一致性并且允许局部失败的算法就是一致性算法。**

### 最终一致性实现

### 拜占庭问题

## Raft介绍

**Raft是一种为了管理复制日志的一致性算法，它提供了和Paxos算法相同的功能和性能，但是Raft的算法结构和Paxos的不一样**，而且Raft算法更加容易理解和实现，为了提高可理解性，Raft将一致性算法分成了几个关键模块：

+ **Leader选举(leader election)**：有且只有一个leader节点，如果leader节点宕机的话，就会通过选举机制选出新的leader。
+ **日志复制(log replication)**：leader从客户端接受数据更新/输出请求，然后日志复制到follower节点，从而保证集群数据的一致性。
+ **安全性 (safety)**：通过安全性原则来处理一些特殊的case，保证Raft算法的完备性。

### Raft状态机

+ follower状态
+ candidate状态
+ leader状态

## 复制状态机

一致算法是从复制状态机的北京下提出来的

**在复制状态机中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行，复制状态机在分布式系统中用来解决容错问题。** **比如大规模的系统中通常有一个集群leader，像GFS、HDFS和RAMCloud**，一个典型的应用就是一个独立的复制状态机去管理Leader选举和存储配置信息并且在Leader宕机的情况下也要存活下来。

**复制状态机通常都是复制日志实现的**，如下图所示，**每台服务器存储一个包含一些的指令日志**，**并且按照日志的顺序进行执行，每个日志按照相同的顺序包含相同的指令**，所以每一个服务器都执行相同的指令序列，**因为状态机都是确定的，每次执行都产生相同的状态和同样的序列**。

![figure1.JPG](https://github.com/Shuimo03/CS-openCourse/blob/main/2021MIT6.824Notes/paperNotes/figure1.JPG?raw=true)

**尽管有些服务器会宕机，但是指令一旦被正确的复制，每一个服务器的状态机都按照日志顺序来处理它们，最后输出结果返回给客户端就可以了，所以服务器集群看来像一个高可靠的状态机。**

一致性算法的工作就是保证复制日志相同，在一台服务器上，一致性模块接受客户端发送出来的指令然后添加到自己的日志中去，它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终以相同顺序包含相同的请求，尽管有些服务器会宕机。

实际系统中使用的一致性算法通常含有以下特性：

+ 安全性保证(绝对不会返回一个错误的结果)：在非拜占庭错情况下，包括网络延迟，分区，丢包，冗余和乱序等错误都可以保证正确。
+ 可用性：**集群中只要有大多数的机器可以运行并且能够相互通信，还能够和客户端通信就可以保证可用。** 比如一个集群里面有五台机器，但是只有两台宕机了，只要剩下的机器它们之间可以通信也可以和客户端通信，那这个集群就没有问题。
+ 通常情况下，一条指令可以尽可能的在集群中大多数节点响应一轮远程调用时完成，小部分比较慢的节点不会影响系统整体的性能。

## Paxos对比Raft

- Raft比Paxos更好理解并且更好实现。
- 在选定leader状态下，multi-paxos和Raft的行为模式是一样的。
- Raft只允许日志最多的节点作为leader，而multi-paxos则相反，任意节点都可以当选leader。
- Raft不允许日志空洞，这是因为为了比较方便和拉平两个节点的日志方便，而multi-paxos则允许日志出现空洞。
- 在Multi-paxos中，任何一个 leader election 算法都可以给 multi-paxos 使用，多个leader并不会破坏算法正确性。

## Raft算法原理

**Raft通过选举领导人(leader)，并且让这个leader来管理复制日志(replicated log)来实现一致性**，leader从客户端接收到日志条目，并把这些日志复制到其他服务器上面，并且当保证安全性的时候告诉其他服务器应用日志条目到他们的状态机中。

拥有一个leader的好处是可以大大的简化了对复制日志的管理，比如leader可以决定新的日志条目需要放在日志中的什么位置，而不需要和其他服务器谈论，并且数据都从leader流向其他服务器。

不过一个leader可能会宕机或者和其他服务器失去连接，在这种情况下一个新的leader会被选举出来。

通过leader方式可以将一致性问题分解成三个独立的子问题：

+ 领导选举(leader election)：当目前的leader失败的时候，一个新的leader就需要被选举出来。
+ 日志复制(Log replication)：leader必须从客户端接收到日志条目(log entries)然后复制到其他集群中的其他节点，并且要求其他节点的日志保持和主机相同。
+ 安全性(Safety)：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点就不能在同一个日志索引应用一个不同的指令。

### 状态解释

[!状态解释](https://github.com/Shuimo03/CS-openCourse/blob/main/2021MIT6.824Notes/paperNotes/state.PNG?raw=true)

### 状态

#### Persistent state on all servers(所有服务器上持久性状态)

所有服务器上的持久性状态(在响应RPC请求之前，已经更新到了稳定的存储设备)

| 参数        | 解释                                                         |
| ----------- | ------------------------------------------------------------ |
| currentTerm | 服务器已知最新的任期(在服务器首次启动的时候初始化为0，单调递增) |
| voteFor     | 当前任期内收到选票的候选者id如果没有投给任何候选者，则为空。 |
| log[]       | 日志条目;每个条目包含了用于状态机的命令，以及领导者接收到该条目的任期(第一个索引为1) |

#### Volatile state on all servers(所有服务器上的易失性状态)

在选举后重新初始化(Reinitialized after election)

| 参数         | 解释                                                         |
| ------------ | ------------------------------------------------------------ |
| nextIndex[]  | 对于每一台服务器，发送到该服务器的下一个日志条目的索引(初始值为leader最后的日志条目索引+1。) |
| matchIndex[] | 对于每一台服务器，已知的已经复制到该服务器的最高日志条目索引(初始值为0，单调递增。) |

### AppendEntries RPC(适应性RPC)

#### Arguments

| 参数         | 解释                                             |
| ------------ | ------------------------------------------------ |
| term         | leader的任期                                     |
| leaderId     | leader的ID，所以follower可以对客户端进行重定向。 |
| prevLogIndex | 紧跟着日志条目之前的那个日志条目的索引。         |
| preLogTerm   | 紧跟着日志条目之前的那个日志条目的任期。         |
| entries[]    | 需要被保存的日志条目                             |
| leaderCommit | leader的已知提交的最高的日志条目索引。           |

#### results

| 参数    | 解释                                                        |
| ------- | ----------------------------------------------------------- |
| term    | 当前任期，对于leader来说它会更新扎吉德任期。                |
| success | 如果follower包含匹配prevLogIndex和prevLogTerm的条目就为真。 |

#### 接受者的实现

### RequestVote RPC

### Rules for Servers

## Raft基础

一个Raft集群包括了若干个服务器的节点，一个典型的例子就是5个服务器节点，它允许2个节点失效，在任何时刻每一个服务器节点都处于以下三种状态之一：

+ 领导人leader
+ 跟随者follower
+ 候选人candidate

在通常情况下，**系统中只有一个leader并且其他节点都是follower，follower都是被动状态，它们不会发送任何信息，只是简单的响应来至leader或者candidate的请求。leader会处理所有的客户端请求。**

![状态转换](https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE4.png)

**follower只响应其他服务器的请求，如果follower接收不到消息，那它就会变成candidate并发起一次选举，**获取集群中大多数投票的候选人将会变成leader，在一个任期内，leader一直都会保持自己的状态直到宕机为止。

![图 5](https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE5.png)

Raft把时间划分成任意长度的任期(term)，如上图所示，任期用连续的整数标记。每一段任期从一次选举开始，一个或者多个candidate尝试成为leader。

如果一个candidate赢得了选举，那它就是在接下来的任期内就会充当leader的职责，在某些情况下，一次选举过程会造成选票被瓜分。

Raft 保证了在一个给定的任期内，最多只有一个leader。

### leader选举

**Raft使用一种心跳机制来触发leader选举，当服务器启动的时候，他们都是follower，只要服务器节点能够接收到leader或者candidate的有效RPCs，那服务器节点就会保持follower状态。**

leader周期性的向所有follower发送心跳包(不包含日志项内容的附加日志项RPC)来维护自己的地位，如**果一个follower节点没有收到这个心跳包就会认为集群里面没有leader节点，那它就会变成candidate然后发起新一轮的选举。**

**当选举开始时，follower状态会先增加自己当前的任期号(term)并且转换到candidate状态，然后它会并行的像集群中其他服务器节点发送请求投票的RPCs来给自己投票。**candidate状态会继续保持当前状态直到遇到以下三件事情中某一种情况才会发生改变：

+ candidate赢得选举，称为leader。
+ 其他服务器成为leader。
+ 在一段之后没有任何一个获胜的人，这些结果分别在下面段落中进行讨论。

**当一个candidate状态从整个集群中的大多数服务器节点获取到了针对同一个任期号的选票，那它就会变成leader**，**每个服务器最多会对一个任期号投出一张选票，按照先来先服务原则。**

要求大多数选票的规则确保了最多只会有一个candidate赢得选举，一旦成为了leader它就会马上的向其他服务器发送心跳消息来建立自己的权威并且阻止新的领导人产生。

在等待投票的时候，candidate可能会从其他服务器收到声明它是leader的附加日志项RPC，**如果这个leader的任期号(包含在此次的 RPC中)大于candidate当前的任期号，那candidate就会承认leader合法随后回到follower状态。**

如果这次RPC中的任期号比自己小，那candidate就会聚集这次RPC并且继续保持当前状态。

**第三种可能的结果就是candidate既没有赢得选举也没有输，那如果又多个follower同时成为候选人，那选票可能会被瓜分从而导致没有candidate可以赢得大多数人的支持，当这种情况发生的时候，每一个候选人都会超时**，然后通过增加当前任期号开始新一轮的选举，然而如果没有其他机制的话，选票就可能再次被无限瓜分。

**为了解决这种情况，Raft使用了随机选举超时时间的方法来确保很少会发生选票瓜分的情况**，就算发生了也能很快的解决，为了阻止选票刚开始就被瓜分，选举超时时间是从一个固定的时间区间中随机选择（例如 150-300 毫秒）。

### 日志复制

一旦一个领导人被选举出来之后，它就会开始为客户端提供服务，客户端的每一个请求都包含了一条被复制状态机执行的指令，**leader会把这条指令作为一条新的日志条目附加到日志中去，然后并行的发起附加条目RPCs给其他服务器**，让他们复制这条日志条目。

当这条日志条目被安全的复制时，leader就会应用这条日志条目倒塌的状态机中然后把执行的结果返回给客户端，如果follower崩溃或者运行缓慢，再或者把网络丢包，领导人会不断的重复尝试附加日志条目 RPCs直到所有的跟随者都最终存储了所有日志条目。

### 安全性

+ 选举限制
+ 提交之前任期内的日志条目
+  安全性论证

### follower和candidate崩溃

面对follower和candidate崩溃的情况，**Raft解决方式很简单并且两种情况处理方式相同，如果follower或者candidate崩溃，那发送给他们的RPCs都会失败，Raft的解决方法就是简单的通过无限重试，如果崩溃的机器重启了，那这些RPC 就会完整的成功，如果一个服务器在完成了一个 RPC，但是还没有响应的时候崩溃了，那么在他重新启动之后就会再次收到同样的请求。**Raft 的 RPCs 都是幂等的，以这样重试不会造成任何问题。

### 问题思考

+ 刚开始服务器中的节点都是follower状态，那如何确定一个follower会变成candidate？
+ 所有的candidate是怎么变成leader？

## 参考资料

+ [分布式一致性算法对比 - Raft VS Paxos - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/88290363)
+ [ Raft算法与paxos算法相比有什么优势，使用场景有什么差异？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/36648084)
+ [Raft-zh_cn/Raft-zh_cn.md at master · maemual/Raft-zh_cn (github.com)](https://github.com/maemual/Raft-zh_cn/blob/master/Raft-zh_cn.md)

