## 智能指针

指针是指一个包含内存地址的变量，这个地址引用或者指向一些其他数据，Rust最常用的指针是引用(&符号)。除了引用数据没有任何其他特殊功能。它们也没有任何额外开销，所以应用得最多。

智能指针(*smart pointers*)是一类数据结构，它们的表现像指针，但是也有额外的元数据和功能。

在Rust中，普通引用和智能指针的一个额外区别是引用知识一类借用数据的指针，相反在大部分情况下，智能指针拥有它们指向的数据。

智能指针通常使用结构体实现，智能指针和普通结构体的区别在于前者实现了Deref和Drop trait。

`Deref` trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码。`Drop` trait 允许我们自定义当智能指针离开作用域时运行的代码。

一些最最常用的智能指针：

+ Box<T> 用于在堆上分配值。
+ Rc<T> 一一个引用计数类型，其数据可以有多个所有者。
+ Ref<T>和RefMut<T>,通过 `RefCell<T>` 访问。（ `RefCell<T>` 是一个在运行时而不是在编译时执行借用规则的类型）。

### 使用Box<T>指向堆上数据

box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。除了数据被存储在堆上而不是在栈上外，box没有性能损失。同时也没有很多额外的功能。box的应用场景如下：

+ 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候。
+ 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候。
+ 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候。

### cons list

###  Deref trait

实现Deref trait允许我们重载解引用运算符，通过这种方式实现Deref trait的智能指针可以被当作常规引用来对待，可以编写操作引用的代码并用于智能指针。

### Drop Trait

Drop的作用是让值要再离开作用域的时候执行一些代码，可以为任何类型提供Drop trait的实现。同时所指定的代码被用于释放类似于文件或者网络连接的资源。

使用智能指针之后必须要调用清理内存或者资源的代码，如果忘记的话，运行代码的系统可能会因为负载过重而崩溃。

在 Rust 中，可以指定每当值离开作用域时被执行的代码，编译器会自动插入这些代码。

### Rc<T> 引用计数智能指针

引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。

RC用于当我们希望在堆上分配一些内存提供给程序多个部分读取，而且无法在编译时确定程序的那一部分会最后结束使用它的时候。如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效。

Rc只用于单线程场景。

`Rc::clone` 的实现并不像大部分类型的 `clone` 实现那样对所有数据进行深拷贝。

### RefCell<T>

内部可变性是Rust中的一个设计模式，它允许开发者在有不可变引用时也可以改变数据。这通常是借用规则不允许的。为了改变数据，该模式在数据结构中使用 `unsafe` 代码来模糊 Rust 通常的可变性和借用规则。

和Rc和TefCell不同的地方在于，它们都代表其数据的唯一所有权，像RefCell这些不可变性作用于运行时。

对于引用，如果违反这些规则，会得到一个编译错误。而对于 `RefCell<T>`，如果违反这些规则程序会 panic 并退出。

`RefCell<T>` 只能用于单线程场景。

### Weak<T>

Weak<T>可以避免引用循环，

### 深拷贝vs浅拷贝

### 强引用vs弱引用

## 停机问题(halting Problem)



